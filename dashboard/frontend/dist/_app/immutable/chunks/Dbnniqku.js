import{d as A,w as s}from"./C-DJuvQO.js";import{g as m}from"./CROMKnEV.js";const G=s(null),y=s([]),k=s(null),h=s([]),H=s(!1),F=s([]),q=s(null),b=s([]),p=s(null),P=s([]),U=s(null),v=s({bestCE:1/0,bestCEAcc:0,bestAcc:0,bestAccCE:1/0,baseline:10.5801});A([k,h],([c,i])=>!c||i.length===0?0:i[i.length-1].iteration_num/c.max_iterations*100);A(h,c=>c.length>0?c[c.length-1].iteration_num:0);A(v,c=>(c.baseline-c.bestCE)/c.baseline*100);let l=null,d=null;function M(){d&&(clearTimeout(d),d=null);const i=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}/ws`;console.log("Connecting to WebSocket:",i),l=new WebSocket(i),l.onopen=()=>{H.set(!0),console.log("WebSocket connected")},l.onclose=()=>{H.set(!1),console.log("WebSocket disconnected, reconnecting in 3s..."),d=setTimeout(M,3e3)},l.onerror=r=>{console.error("WebSocket error:",r)},l.onmessage=r=>{try{const u=JSON.parse(r.data);N(u)}catch(u){console.error("Failed to parse WebSocket message:",u)}}}function N(c){var i,r,u,E,S,I,x,W;switch(console.log("WS message:",c.type),c.type){case"Snapshot":{const e=c.data;console.log("Received snapshot:",(i=e.phases)==null?void 0:i.length,"phases",(r=e.iterations)==null?void 0:r.length,"iterations"),G.set(e.current_experiment),y.set(e.phases||[]);let t=e.current_phase;!t&&e.phases&&e.phases.length>0&&(t=e.phases.find(o=>o.status==="running")||e.phases.reduce((o,$)=>o.sequence_order>$.sequence_order?o:$),console.log("No current_phase in snapshot, using fallback:",t==null?void 0:t.name)),k.set(t||null);const a=e.iterations||[],n=t==null?void 0:t.id,_=n?a.filter(o=>o.phase_id===n):a;h.set(_);const T=_.map(o=>({iter:o.iteration_num,ce:o.best_ce,acc:o.best_accuracy,avgCe:o.avg_ce,avgAcc:o.avg_accuracy}));F.set(T);let g=e.best_ce||1/0,w=0,f=0,C=1/0;const R=e.iterations||[];for(const o of R)o.best_ce<g&&(g=o.best_ce,w=o.best_accuracy||0),o.best_accuracy&&o.best_accuracy>f&&(f=o.best_accuracy,C=o.best_ce);R.length===0&&(g=e.best_ce||1/0,w=e.best_accuracy||0,f=e.best_accuracy||0,C=e.best_ce||1/0),v.set({bestCE:g,bestCEAcc:w,bestAcc:f,bestAccCE:C,baseline:10.5801});break}case"IterationCompleted":{const e=c.data;console.log(`[Iter ${e.iteration_num}] CE=${(u=e.best_ce)==null?void 0:u.toFixed(4)}, Acc=${((E=e.best_accuracy)==null?void 0:E.toFixed(4))??"null"}%, AvgCE=${((S=e.avg_ce)==null?void 0:S.toFixed(4))??"null"}, AvgAcc=${((I=e.avg_accuracy)==null?void 0:I.toFixed(4))??"null"}%`);const t=m(k);if(t&&e.phase_id!==t.id){console.log(`[Iter ${e.iteration_num}] Skipping - different phase (${e.phase_id} vs ${t.id})`);break}h.update(a=>a.some(_=>_.id===e.id)?a:[...a,e].slice(-500)),F.update(a=>[...a,{iter:e.iteration_num,ce:e.best_ce,acc:e.best_accuracy,avgCe:e.avg_ce,avgAcc:e.avg_accuracy}]),v.update(a=>{const n={...a};return e.best_ce<a.bestCE&&(n.bestCE=e.best_ce,n.bestCEAcc=e.best_accuracy||0),e.best_accuracy&&e.best_accuracy>a.bestAcc&&(n.bestAcc=e.best_accuracy,n.bestAccCE=e.best_ce),n});break}case"PhaseStarted":{const e=c.data;y.update(t=>[...t,e]),k.set(e),h.set([]),F.set([]),console.log("Phase started:",e.name);break}case"PhaseCompleted":{const e=c.data;y.update(t=>t.map(a=>a.id===e.id?e:a)),console.log("Phase completed:",e.name);break}case"HealthCheck":{q.set(c.data),console.log("Health check:",c.data);break}case"ExperimentStatusChanged":{const e=c.data;G.set(e),console.log("Experiment status changed:",e.status);break}case"FlowStarted":{const e=c.data;b.update(t=>t.find(n=>n.id===e.id)?t.map(n=>n.id===e.id?e:n):[...t,e]),p.set(e),console.log("Flow started:",e.name);break}case"FlowCompleted":{const e=c.data;b.update(t=>t.map(a=>a.id===e.id?e:a)),e.id===((x=m(p))==null?void 0:x.id)&&p.set(e),console.log("Flow completed:",e.name);break}case"FlowFailed":{const{flow:e,error:t}=c.data;b.update(a=>a.map(n=>n.id===e.id?e:n)),console.error("Flow failed:",e.name,t);break}case"FlowQueued":{const e=c.data;b.update(t=>t.find(n=>n.id===e.id)?t.map(n=>n.id===e.id?e:n):[...t,e]),p.set(e),console.log("Flow queued:",e.name);break}case"FlowCancelled":{const e=c.data;b.update(t=>t.map(a=>a.id===e.id?e:a)),((W=m(p))==null?void 0:W.id)===e.id&&p.set(e),console.log("Flow cancelled:",e.name);break}case"CheckpointCreated":{const e=c.data;P.update(t=>[...t,e]),console.log("Checkpoint created:",e.name);break}case"CheckpointDeleted":{const{id:e}=c.data;P.update(t=>t.filter(a=>a.id!==e)),console.log("Checkpoint deleted:",e);break}case"GatingRunCreated":case"GatingRunUpdated":{const e=c.data;U.set(e),console.log(`Gating run ${c.type==="GatingRunCreated"?"created":"updated"} for experiment ${e.experiment_id}:`,e.status);break}}}function J(){d&&(clearTimeout(d),d=null),l==null||l.close(),l=null}export{p as a,M as b,P as c,J as d,b as f,U as g,H as w};
